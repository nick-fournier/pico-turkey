<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Include Bootstrap CSS with Darkly theme -->
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <title>Turkey Temperature!</title>
</head>
<body class="bg-dark text-white">

<div id="time-series-plot"></div>

<div>
  <label for="forecastDuration">Enter forecast duration (minutes): </label>
  <input type="number" id="forecastDuration" value="10" min="1">
  <!-- <button onclick="updatePlot()" class="btn btn-primary">Forecast</button> -->
</div>

<script>
  function updatePlot() {
    // Fetch JSON with nested data from the server
    fetch('{{webhost}}') // Replace with your server endpoint
      .then(response => response.json())
      .then(jsonData => {
        // Extract top  <!-- <button onclick="updatePlot()" class="btn btn-primary">Forecast</button>-level fields
        var rate = jsonData.rate;
        var nestedData = jsonData.data;

        // Convert timestamp strings to JavaScript Date objects
        nestedData.forEach(function (entry) {
          entry.timestamp = new Date(entry.timestamp);
        });

        // Extract timestamps and temperatures from nested data
        var timestamps = nestedData.map(function (entry) {
          return entry.timestamp;
        });

        var temperatures = nestedData.map(function (entry) {
          return entry.temperature;
        });

        // User input for forecast duration
        var forecastDurationInput = document.getElementById('forecastDuration');
        var forecastDuration = parseInt(forecastDurationInput.value);

        // Forecast temperature for the specified duration using the "rate"
        var forecastTimestamps = [];
        var forecastTemperatures = [];

        for (var i = 0; i <= forecastDuration; i++) {
          var forecastTimestamp = new Date(timestamps[timestamps.length - 1].getTime() + i * 60 * 1000);
          var forecastTemperature = temperatures[temperatures.length - 1] + rate * i;

          forecastTimestamps.push(forecastTimestamp);
          forecastTemperatures.push(forecastTemperature);
        }

        // Create the time series mountain plot
        var trace = {
          x: timestamps,
          y: temperatures,
          type: 'scatter',
          mode: 'lines',
          fill: 'tozeroy',
          line: {
            color: 'rgb(0, 100, 255)',
          },
          name: 'Actual Temperature',
        };

        // Create the forecast trace
        var forecastTrace = {
          x: forecastTimestamps,
          y: forecastTemperatures,
          type: 'scatter',
          mode: 'lines',
          line: {
            color: 'rgb(255, 0, 0)',
            dash: 'dot',  // Set the line style to dotted
          },
          name: 'Forecasted Temperature',
        };

        var layout = {
          title: {
            text: 'Turkey Temperature!',
            font: {
              color: 'white',  // Title text color
            },
          },
          xaxis: {
            title: {
              text: 'Timestamp',
              font: {
                color: 'white',  // X-axis title text color
              },
            },
            tickfont: {
              color: 'white',  // Tick label text color
            },
            tickformat: '%I:%M %p', // Format as HH:MM in 12-hour format
            showgrid: true,  // Display grid lines on the x-axis
            gridcolor: 'gray',  // Set grid lines color
          },
          yaxis: {
            title: {
              text: 'Temperature',
              font: {
                color: 'white',  // Y-axis title text color
              },
            },
            tickfont: {
              color: 'white',  // Tick label text color
            },
            showgrid: true,  // Display grid lines on the y-axis
            gridcolor: 'gray',  // Set grid lines color
          },
          legend: {
            font: {
              color: 'white',  // Legend font color
            },
          },
          paper_bgcolor: 'rgba(0,0,0,0)',  // Transparent background color of the chart
          plot_bgcolor: 'rgba(0,0,0,0.1)',   // Transparent background color of the plot area
        };

        var data = [trace, forecastTrace];

        // Use Plotly to create or update the plot
        Plotly.newPlot('time-series-plot', data, layout);
      })
      .catch(error => console.error('Error fetching data:', error));
  }

  // Call the updatePlot function initially
  updatePlot();

  // Set up an interval to update the plot every 5 seconds
  setInterval(updatePlot, 5000);
</script>

</body>
</html>
